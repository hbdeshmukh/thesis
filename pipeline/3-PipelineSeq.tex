\section{Pipeline Sequencing Algorithm}\label{sec:pipe-seq-algo}
We now describe our algorithm for sequencing pipelines in a query plan. 
We make the following assumptions for the use of our algorithm. 
We assume that only one pipeline is executed at a time.
Simultaneous execution of multiple pipelines could pollute the cache, thus making it harder to reason about performance.

We assume a hash-based implementation of join algorithms.
A logical join operation has corresponding two physical operators: a build operator that builds the hash table and a probe operator that lets the input probe the hash table.
The probe operator does not begin its execution until the build operator's execution is over.
Each pipeline has a unique ID. 
Unless specified, we assume that there is enough memory available to execute a query. 

\begin{algorithm}
	\caption{Pipeline Sequencing Algorithm}
	\begin{algorithmic}[1]
		\Function{getSequence}{Pipeline p, Sequence s}
		\State children = p.getInputPipelines();
		\State sortPipelines(children) 		\label{alg:sort}
		\For {child $\in$ children}:
			\State \textsc{getSequence}(child, s)
		\EndFor
		\State s.append(p)		
		\EndFunction		
		\State 
		\State \Comment {Returns true if pipeline a should be executed before
		pipeline b, otherwise return false.}
		\Function{pipelineComparator}{Pipeline a, Pipeline b}\label{alg:comparator}

		\If {a.lastOperator() == BUILD}
			\State return true
		\ElsIf {b.lastOperator() == BUILD}
			\State return false
		\Else
			\State return a.pipelineID() < b.pipelineID()\label{alg:break-ties}
		\EndIf
		\EndFunction		
	\end{algorithmic}
	\label{alg:pipeline-sequence}
\end{algorithm}

We present the algorithm to sequence the pipelines in a query plan for execution in  Algorithm~\ref{alg:pipeline-sequence}.
The algorithm is a variation of depth first traversal. 
The key intuition behind the algorithm is to construct the hash tables for the join early and facilitate the pipelining for the probing, by delaying the execution of the probe operator.
There are two kinds of inputs for a probe operator - the probe relation and the hash table.
By nature, the accesses within the hash table are random, where as the access pattern for the probe relation is sequential. 
Therefore during the probe operation we prefer probe relation being hot in caches, as opposed to the hash table being hot.

The function \textsc{getSequence} produces a sequence of pipelines in a recursive manner.
Given a pipeline that has multiple incoming pipelines, which pipeline should be executed earlier?
To answer this question, we sort the incoming pipelines using a custom comparator described in the function \textsc{pipelineComparator} in Line~\ref{alg:comparator}.
The \textit{smaller} pipeline is executed earlier. 
We now describe the sorting criterion.
As mentioned earlier, we want the build hash operator to execute sooner, therefore we treat them \textit{smaller}, as compared to the pipelines ending with a non-build hash operator.
In case of multiple incoming pipelines ending with build hash operator (Line~\ref{alg:break-ties}), we break the ties by declaring the pipeline with a smaller ID as smaller.
\todo{Show an example.}