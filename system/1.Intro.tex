% !TEX root = quickstep.tex
\chapter{Design and Implementation of Quickstep System}

\section{Introduction}
Query processing systems today face a host of challenges that were not as prominent just a few years ago. A key change has been dramatic changes in the hardware landscape that is driven by the need to consider energy as a first-class (hardware) design parameter. Across the entire processor-IO hierarchy, the hardware paradigm today looks very different than it did just a few years ago. Consequently, we are now experiencing a growing \textit{deficit} between the pace of hardware performance improvements and the pace that is demanded of data processing kernels to keep up with the growth in data volumes.

%\begin{figure}
%\centering
%   \includegraphics[width=\columnwidth]{system/figures/deficit.pdf}
%   \vspace*{-2em}
%   \caption{\textbf{Processor performance improvement as measured by the highest reported CINT2006 benchmark result for Intel Xeon chips from~\cite{cpu2006} compared to the number of pages indexed by Google (using estimates made by~\cite{google-pages-db}). The figure does not show the increase in the number of queries (which is about 2.5X for Google search queries from 2011--14), and the increase in the complexity of queries as applications request richer analytics. These aspects make the deficit problem worse. The figure also shows the maximum number of cores per chip used in reported CINT2006 results over time. Interestingly (and not shown in the figure), both the minimum and the average amount of memory per chip in the reported CINT2006 results has grown by $\approx$4X from 2011 to 2017.}}
%   % For example, the number of Google search queries has gone up by a factor of 6X in the time period shown in the graph above.}
%   \label{fig-deficit}
%\end{figure}

Figure~\ref{fig-deficit} illustrates this deficit issue by comparing improvements in processor performance (blue line) with the growth rate of data (green line), using the number of pages indexed by Google as an illustrative example. This data growth rate is conservative for many organizations, which tend to see a far higher rate of increase in the data volume; for example, Facebook's warehouse grew by 3X in 2014~\cite{fb-growth-14}. This figure also shows (using a dotted orange line with squares) the growth in the number of cores per processor over time. As one can observe, the number of cores per processor is rising rapidly. % as multi-core parallelism is critical for processor vendors.
%to realizing overall higher processor performance.
%(While we do not consider this further in this paper, the number of cores per processing unit is even higher for non-traditional processors/co-processors.)
% Thus, the demands on query processing can't simply be met by only throwing more chips/processors at the problem.
%Thus, there is a critical need for systems that can exploit the full potential of the hardware parallelism that is available in each box.
In addition, %as noted in the caption of the figure,
since 2011 the main memory sizes are also growing rapidly, and there is an increasing shift to larger main memory configurations. 
Thus, there is a critical need for in-memory data processing methods that \textit{scale-up} to exploit the full (parallel) processing power that is locked in commodity multi-core servers today. \Quickstep\ targets this need, and in this chapter we describe the initial version of Quickstep that targets single-node in-memory read-mostly analytic workloads.

%Next, we describe key aspects of the Quickstep system.
To pay off the deficit, Quickstep uses mechanisms that allow for \textit{high intra-operator parallelism}. 
Such mechanisms are critical to exploit the full potential of the high level of hardware compute parallelism that is present in modern servers (the dotted orange line in Figure~\ref{fig-deficit}).

Unlike most research database management systems (DBMSs), \Quickstep\ has a storage manager with a block layout, where each block behaves like a mini self-contained database~\cite{ChasseurP13}.
This ``independent'' block-based storage design is leveraged by a highly parallelizable query execution paradigm in which independent \textit{work orders} are generated at the block level. Query execution then amounts to creating and scheduling work orders, which can be done in a generic way. Thus, the scheduler is a crucial system component, and the Quickstep scheduler cleanly separates scheduling policies from the underlying scheduling mechanisms. This separation allows the system to elastically scale the resources that are allocated to queries, and to adjust the resource allocations dynamically to meet various policy-related goals.

Recognizing that random memory access patterns and materialization costs often dominate the execution time in main-memory DBMSs, Quickstep uses a number of query processing techniques that take the ``drop early, drop fast'' approach: eliminating redundant rows as early as possible, as fast as possible. For instance, Quickstep aggressively pushes down complex disjunctive predicates involving multiple tables using a %novel
predicate over-approximation scheme. Quickstep also uses cache-efficient filter data structures to pass information across primary key-foreign key equijoins,  eliminating semi-joins entirely in some cases. 

\begin{figure}
	\centering
	\includegraphics[width=0.75\textwidth]{system/figures/tpch-q10-waterfall.pdf}
	\caption{\textbf{A waterfall chart showing the impact of various techniques in Quickstep for query 10 from the TPC-H benchmark running on a 100 scale factor database. RS (Row Store), and CCS (Compressed Column Store) are both supported in Quickstep (see Section~\ref{block-structure}). Basic and Selection are template metaprogramming optimizations (described in Section~\ref{vectorization}), which relate to the efficiency of predicate and expression evaluation. LIP (Lookahead Information Passing, described in Section~\ref{sec:lip}) is a technique to improve join performance. Starting with a configuration (Basic + RS), each technique is introduced one at a time to show the individual impact of each technique on this query.}}
	\label{fig:tpch-q10-waterfall}
\end{figure}

Overall, the key contributions of our work are as follows:\\

\textbf{Cohesive collection of techniques:} We present the first end-to-end design for Quickstep. This system brings together in a single artifact a number of mechanisms for in-memory query processing such as support for multiple storage formats, a template metaprogramming approach to both manage the software complexity associated with supporting multiple storage formats and to evaluate expressions on data in each storage format efficiently, and novel query optimization techniques.
The impact of each mechanism depends on the workload, and our system brings these mechanisms together as a whole.
For example, the waterfall chart in Figure~\ref{fig:tpch-q10-waterfall} shows the contributions of various techniques on the performance of TPC-H Query 10.

\paragraph{Novel query processing techniques:} We present Quickstep's use of techniques to aggressively push down complex disjunctive predicates involving multiple relations, as well as to eliminate certain types of equijoins using \textit{exact filters}.

\paragraph{Manageability:} The design of the system focuses on ease-of-use, paying attention to a number of issues, including employing methods such as using a holistic approach to memory management, and elastically scaling query resource usage at runtime to gracefully deal with concurrent queries with varying query priorities.

\paragraph{Comparison with other systems:} We also conduct an end-to-end evaluation comparing \Quickstep\ with a number of other systems. These system are: Spark~\cite{Spark, SparkSQL}, PostgreSQL~\cite{postgres}, MonetDB~\cite{monetdb}, and VectorWise~\cite{vectorwise}. Our results show that in many cases, Quickstep is faster by an order-of-magnitude, or more.

We also leverage the multiple different storage implementations in Quickstep to better understand the end-to-end impact of the popular row store and column store methods on the SSB and TPC-H queries. To the best of our knowkedge, an apples-to-apples comparison of these benchmark queries does not exist. We show that overall column stores are still preferred, though the speed up overall is only about 2X. Earlier comparisions, e.g.~\cite{AbadiMH08}, have been indirect comparisons of this aspect of storage management for the SSB benchmark across two different systems, and show far larger (6X) improvements. %We also find that overall for the SSB benchmark compression does not produce significant benefits.

\paragraph{Open source:} Quickstep\ is available as open-source, which we hope helps the reproducability goal that is being pursued in our community~\cite{BonnetMBCGGHIIJKKMOPRTYFS11, ManegoldMAFGHHKKLLORSSWS09, ManolescuAADMPSSZS08}. It also allows other researchers to use this system as a platform when working on  problems where the impact of specific techniques can be best studied within the context of the overall system behavior.

The remainder of this chapter is organized as follows: The overall Quickstep architecture is presented in the next section. The storage manager in presented in Section~\ref{storage-manager}. The query execution and scheduling methods are presented in Sections~\ref{query-exec} and~\ref{sec:query-opt} respectively. Empirical results are presented in Section~\ref{evaluation}, and related work is presented in Section~\ref{related}. Finally, Section~\ref{conclusions} contains our concluding remarks.