Analytical database systems process data to find insights. 
Database systems today are facing challenges from multiple fronts: First, there is an unprecedented data being generated by machines and humans.
Second, there is a diverse demand for analytics which includes data warehousing and predictive analytics.
Third, the hardware landscape keeps evolving which means the database system need to keep up in order to reap the best out of the hardware.
Finally, cloud computing challenges the many assumptions regarding deployment environments, availability of compute resources, storage and network resources that the traditional systems were built with.
Given these challenges, modern database systems need to manage the resources at their disposal \textit{efficiently} - to produce faster results, \textit{effectively} - to fully utilize the resources and \textit{transparently} - to be accountable to its users.

We present a query scheduler designed for the Quickstep database system that imparts efficiency, effectiveness and transparency to the resource management of the system. 

In the first chapter we present the makeup of the Quickstep system. 
We describe a task abstraction called \textit{work orders}, which is used by the scheduler for co-ordinating the execution of a query.
Through work orders, Quickstep scheduler gets a fine grained control over query execution, and thus allows the system to exploit large amounts of parallelism offered by the modern hardware.

Next we showcase the usefulness of the Quickstep scheduler as it solves two challenges: resource governance and performance.
In the second chapter, we employ the Quickstep scheduler for allocating resources such as CPU to concurrent users of the system.
The resource allocation can understand high level policies such as fair and priority-based, and enforces them while allocating the resources.
The scheduler has a learning component, which constantly monitors the resource consumption happening in the system, anticipates the future resource requirements and adjusts the resource allocation so as to meet the policy goals.
Our experiments demonstrate that we are able to meet these policy goals.

In the final chapter, we highlight the impact of scheduling techniques on query performance.
We turn to pipelining, which is a well known query processing technique, used since the times of disk-based systems.
We revisit the importance of pipelining in the in-memory systems and examine the role of various parameters such as block size, parallelism, storage format and hardware prefetching.
We find that the performance of queries with and without pipelining does not differ as radically as it does in the disk-based environment.
We explain the reasons for this similarity of performance between strategies through empirical evaluation as well as an analytical model.
Our study points to a reduced role of pipelining in the in-memory environments for systems using a block-based query processing approach. 